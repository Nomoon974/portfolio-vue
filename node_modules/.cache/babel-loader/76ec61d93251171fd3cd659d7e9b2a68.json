{"ast":null,"code":"import _typeof from \"C:/Users/lucas/IdeaProjects/portfolio-vue/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\n\n/*!\n * MotionPathPlugin 3.10.3\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { getRawPath, cacheRawPathMeasurements, getPositionOnPath, pointsToSegment, flatPointsToSegment, sliceRawPath, stringToRawPath, rawPathToString, transformRawPath, convertToPath as _convertToPath } from \"./utils/paths.js\";\nimport { getGlobalMatrix } from \"./utils/matrix.js\";\n\nvar _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n    _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n    _DEG2RAD = Math.PI / 180,\n    gsap,\n    PropTween,\n    _getUnit,\n    _toArray,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {\n  //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n  var l = values.length,\n      si = mode === 2 ? 0 : mode,\n      i = 0,\n      v;\n\n  for (; i < l; i++) {\n    segment[si] = v = parseFloat(values[i][property]);\n    mode === 2 && (segment[si + 1] = 0);\n    si += 2;\n  }\n\n  return segment;\n},\n    _getPropNum = function _getPropNum(target, prop, unit) {\n  return parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0;\n},\n    _relativize = function _relativize(segment) {\n  var x = segment[0],\n      y = segment[1],\n      i;\n\n  for (i = 2; i < segment.length; i += 2) {\n    x = segment[i] += x;\n    y = segment[i + 1] += y;\n  }\n},\n    // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n// _quadToCubic = points => {\n// \tlet cubic = [],\n// \t\tl = points.length - 1,\n// \t\ti = 1,\n// \t\ta, b, c;\n// \tfor (; i < l; i+=2) {\n// \t\ta = points[i-1];\n// \t\tb = points[i];\n// \t\tc = points[i+1];\n// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n// \t}\n// \tcubic.push(points[l]);\n// \treturn cubic;\n// },\n_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {\n  if (vars.type === \"cubic\") {\n    segment = [segment];\n  } else {\n    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n    vars.relative && _relativize(segment);\n    var pointFunc = y ? pointsToSegment : flatPointsToSegment;\n    segment = [pointFunc(segment, vars.curviness)];\n  }\n\n  segment = slicer(_align(segment, target, vars));\n\n  _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n\n  y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n  return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n},\n    _emptyFunc = function _emptyFunc(v) {\n  return v;\n},\n    _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n    _originToPoint = function _originToPoint(element, origin, parentMatrix) {\n  // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n  var m = getGlobalMatrix(element),\n      x = 0,\n      y = 0,\n      svg;\n\n  if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n    svg = element.viewBox.baseVal;\n    svg.width || (svg = {\n      width: +element.getAttribute(\"width\"),\n      height: +element.getAttribute(\"height\")\n    });\n  } else {\n    svg = origin && element.getBBox && element.getBBox();\n  }\n\n  if (origin && origin !== \"auto\") {\n    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n  }\n\n  return parentMatrix.apply(x || y ? m.apply({\n    x: x,\n    y: y\n  }) : {\n    x: m.e,\n    y: m.f\n  });\n},\n    _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {\n  var parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\n      m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\n      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n      _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix),\n      x = _originToPoint2.x,\n      y = _originToPoint2.y,\n      p;\n\n  m.e = m.f = 0;\n\n  if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n    p = toElement.getAttribute(\"d\").match(_numExp) || [];\n    p = m.apply({\n      x: +p[0],\n      y: +p[1]\n    });\n    x += p.x;\n    y += p.y;\n  }\n\n  if (p || toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement) {\n    p = m.apply(toElement.getBBox());\n    x -= p.x;\n    y -= p.y;\n  }\n\n  m.e = x - fromPoint.x;\n  m.f = y - fromPoint.y;\n  return m;\n},\n    _align = function _align(rawPath, target, _ref) {\n  var align = _ref.align,\n      matrix = _ref.matrix,\n      offsetX = _ref.offsetX,\n      offsetY = _ref.offsetY,\n      alignOrigin = _ref.alignOrigin;\n\n  var x = rawPath[0][0],\n      y = rawPath[0][1],\n      curX = _getPropNum(target, \"x\"),\n      curY = _getPropNum(target, \"y\"),\n      alignTarget,\n      m,\n      p;\n\n  if (!rawPath || !rawPath.length) {\n    return getRawPath(\"M0,0L0,0\");\n  }\n\n  if (align) {\n    if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n      transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n    } else {\n      if (alignOrigin && alignOrigin[2] !== false) {\n        gsap.set(target, {\n          transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n        });\n      } else {\n        alignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n      }\n\n      m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n      p = m.apply({\n        x: x,\n        y: y\n      });\n      transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n    }\n  }\n\n  if (matrix) {\n    transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n  } else if (offsetX || offsetY) {\n    transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n  }\n\n  return rawPath;\n},\n    _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {\n  var cache = target._gsap,\n      harness = cache.harness,\n      alias = harness && harness.aliases && harness.aliases[property],\n      prop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n  pt.path = rawPath;\n  pt.pp = pathProperty;\n\n  plugin._props.push(prop);\n},\n    _sliceModifier = function _sliceModifier(start, end) {\n  return function (rawPath) {\n    return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;\n  };\n};\n\nexport var MotionPathPlugin = {\n  version: \"3.10.3\",\n  name: \"motionPath\",\n  register: function register(core, Plugin, propTween) {\n    gsap = core;\n    _getUnit = gsap.utils.getUnit;\n    _toArray = gsap.utils.toArray;\n    PropTween = propTween;\n  },\n  init: function init(target, vars) {\n    if (!gsap) {\n      console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n      return false;\n    }\n\n    if (!(_typeof(vars) === \"object\" && !vars.style) || !vars.path) {\n      vars = {\n        path: vars\n      };\n    }\n\n    var rawPaths = [],\n        _vars = vars,\n        path = _vars.path,\n        autoRotate = _vars.autoRotate,\n        unitX = _vars.unitX,\n        unitY = _vars.unitY,\n        x = _vars.x,\n        y = _vars.y,\n        firstObj = path[0],\n        slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1),\n        rawPath,\n        p;\n\n    this.rawPaths = rawPaths;\n    this.target = target;\n\n    if (this.rotate = autoRotate || autoRotate === 0) {\n      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n      this.rOffset = parseFloat(autoRotate) || 0;\n      this.radians = !!vars.useRadians;\n      this.rProp = vars.rotation || \"rotation\"; // rotation property\n\n      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n\n      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n    }\n\n    if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n      for (p in firstObj) {\n        if (!x && ~_xProps.indexOf(p)) {\n          x = p;\n        } else if (!y && ~_yProps.indexOf(p)) {\n          y = p;\n        }\n      }\n\n      if (x && y) {\n        //correlated values\n        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n      } else {\n        x = y = 0;\n      }\n\n      for (p in firstObj) {\n        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n      }\n    } else {\n      rawPath = slicer(_align(getRawPath(vars.path), target, vars));\n      cacheRawPathMeasurements(rawPath, vars.resolution);\n      rawPaths.push(rawPath);\n\n      _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n\n      _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n    }\n  },\n  render: function render(ratio, data) {\n    var rawPaths = data.rawPaths,\n        i = rawPaths.length,\n        pt = data._pt;\n\n    if (ratio > 1) {\n      ratio = 1;\n    } else if (ratio < 0) {\n      ratio = 0;\n    }\n\n    while (i--) {\n      getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n    }\n\n    while (pt) {\n      pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n      pt = pt._next;\n    }\n\n    data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n  },\n  getLength: function getLength(path) {\n    return cacheRawPathMeasurements(getRawPath(path)).totalLength;\n  },\n  sliceRawPath: sliceRawPath,\n  getRawPath: getRawPath,\n  pointsToSegment: pointsToSegment,\n  stringToRawPath: stringToRawPath,\n  rawPathToString: rawPathToString,\n  transformRawPath: transformRawPath,\n  getGlobalMatrix: getGlobalMatrix,\n  getPositionOnPath: getPositionOnPath,\n  cacheRawPathMeasurements: cacheRawPathMeasurements,\n  convertToPath: function convertToPath(targets, swap) {\n    return _toArray(targets).map(function (target) {\n      return _convertToPath(target, swap !== false);\n    });\n  },\n  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {\n    var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n    return point ? m.apply(point) : m;\n  },\n  getAlignMatrix: _getAlignMatrix,\n  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n\n    return {\n      x: m.e,\n      y: m.f\n    };\n  },\n  arrayToRawPath: function arrayToRawPath(value, vars) {\n    vars = vars || {};\n\n    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n\n    vars.relative && _relativize(segment);\n    return [vars.type === \"cubic\" ? segment : pointsToSegment(segment, vars.curviness)];\n  }\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\nexport { MotionPathPlugin as default };","map":{"version":3,"sources":["C:/Users/lucas/IdeaProjects/portfolio-vue/node_modules/gsap/MotionPathPlugin.js"],"names":["getRawPath","cacheRawPathMeasurements","getPositionOnPath","pointsToSegment","flatPointsToSegment","sliceRawPath","stringToRawPath","rawPathToString","transformRawPath","convertToPath","_convertToPath","getGlobalMatrix","_xProps","split","_yProps","_DEG2RAD","Math","PI","gsap","PropTween","_getUnit","_toArray","_getGSAP","window","registerPlugin","_populateSegmentFromArray","segment","values","property","mode","l","length","si","i","v","parseFloat","_getPropNum","target","prop","unit","_gsap","get","_relativize","x","y","_segmentToRawPath","plugin","slicer","vars","unitX","unitY","type","fromCurrent","unshift","relative","pointFunc","curviness","_align","_addDimensionalPropTween","resolution","_emptyFunc","_numExp","_originToPoint","element","origin","parentMatrix","m","svg","tagName","toLowerCase","viewBox","baseVal","width","getAttribute","height","getBBox","push","offsetWidth","offsetHeight","apply","e","f","_getAlignMatrix","fromElement","toElement","fromOrigin","toOrigin","parentNode","clone","multiply","fromPoint","_originToPoint2","p","getTotalLength","match","ownerSVGElement","rawPath","_ref","align","matrix","offsetX","offsetY","alignOrigin","curX","curY","alignTarget","set","transformOrigin","a","b","c","d","pathProperty","forceUnit","cache","harness","alias","aliases","indexOf","pt","_pt","u","path","pp","_props","_sliceModifier","start","end","MotionPathPlugin","version","name","register","core","Plugin","propTween","utils","getUnit","toArray","init","console","warn","style","rawPaths","_vars","autoRotate","firstObj","rotate","rOffset","radians","useRadians","rProp","rotation","rSet","ru","Array","isArray","render","ratio","data","t","_next","angle","getLength","totalLength","targets","swap","map","convertCoordinates","point","getAlignMatrix","getRelativePosition","arrayToRawPath","value","default"],"mappings":"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","sourcesContent":["/*!\n * MotionPathPlugin 3.10.3\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { getRawPath, cacheRawPathMeasurements, getPositionOnPath, pointsToSegment, flatPointsToSegment, sliceRawPath, stringToRawPath, rawPathToString, transformRawPath, convertToPath as _convertToPath } from \"./utils/paths.js\";\nimport { getGlobalMatrix } from \"./utils/matrix.js\";\n\nvar _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n    _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n    _DEG2RAD = Math.PI / 180,\n    gsap,\n    PropTween,\n    _getUnit,\n    _toArray,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {\n  //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n  var l = values.length,\n      si = mode === 2 ? 0 : mode,\n      i = 0,\n      v;\n\n  for (; i < l; i++) {\n    segment[si] = v = parseFloat(values[i][property]);\n    mode === 2 && (segment[si + 1] = 0);\n    si += 2;\n  }\n\n  return segment;\n},\n    _getPropNum = function _getPropNum(target, prop, unit) {\n  return parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0;\n},\n    _relativize = function _relativize(segment) {\n  var x = segment[0],\n      y = segment[1],\n      i;\n\n  for (i = 2; i < segment.length; i += 2) {\n    x = segment[i] += x;\n    y = segment[i + 1] += y;\n  }\n},\n    // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n// _quadToCubic = points => {\n// \tlet cubic = [],\n// \t\tl = points.length - 1,\n// \t\ti = 1,\n// \t\ta, b, c;\n// \tfor (; i < l; i+=2) {\n// \t\ta = points[i-1];\n// \t\tb = points[i];\n// \t\tc = points[i+1];\n// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n// \t}\n// \tcubic.push(points[l]);\n// \treturn cubic;\n// },\n_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {\n  if (vars.type === \"cubic\") {\n    segment = [segment];\n  } else {\n    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n    vars.relative && _relativize(segment);\n    var pointFunc = y ? pointsToSegment : flatPointsToSegment;\n    segment = [pointFunc(segment, vars.curviness)];\n  }\n\n  segment = slicer(_align(segment, target, vars));\n\n  _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n\n  y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n  return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n},\n    _emptyFunc = function _emptyFunc(v) {\n  return v;\n},\n    _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n    _originToPoint = function _originToPoint(element, origin, parentMatrix) {\n  // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n  var m = getGlobalMatrix(element),\n      x = 0,\n      y = 0,\n      svg;\n\n  if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n    svg = element.viewBox.baseVal;\n    svg.width || (svg = {\n      width: +element.getAttribute(\"width\"),\n      height: +element.getAttribute(\"height\")\n    });\n  } else {\n    svg = origin && element.getBBox && element.getBBox();\n  }\n\n  if (origin && origin !== \"auto\") {\n    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n  }\n\n  return parentMatrix.apply(x || y ? m.apply({\n    x: x,\n    y: y\n  }) : {\n    x: m.e,\n    y: m.f\n  });\n},\n    _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {\n  var parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\n      m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\n      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n      _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix),\n      x = _originToPoint2.x,\n      y = _originToPoint2.y,\n      p;\n\n  m.e = m.f = 0;\n\n  if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n    p = toElement.getAttribute(\"d\").match(_numExp) || [];\n    p = m.apply({\n      x: +p[0],\n      y: +p[1]\n    });\n    x += p.x;\n    y += p.y;\n  }\n\n  if (p || toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement) {\n    p = m.apply(toElement.getBBox());\n    x -= p.x;\n    y -= p.y;\n  }\n\n  m.e = x - fromPoint.x;\n  m.f = y - fromPoint.y;\n  return m;\n},\n    _align = function _align(rawPath, target, _ref) {\n  var align = _ref.align,\n      matrix = _ref.matrix,\n      offsetX = _ref.offsetX,\n      offsetY = _ref.offsetY,\n      alignOrigin = _ref.alignOrigin;\n\n  var x = rawPath[0][0],\n      y = rawPath[0][1],\n      curX = _getPropNum(target, \"x\"),\n      curY = _getPropNum(target, \"y\"),\n      alignTarget,\n      m,\n      p;\n\n  if (!rawPath || !rawPath.length) {\n    return getRawPath(\"M0,0L0,0\");\n  }\n\n  if (align) {\n    if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n      transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n    } else {\n      if (alignOrigin && alignOrigin[2] !== false) {\n        gsap.set(target, {\n          transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n        });\n      } else {\n        alignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n      }\n\n      m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n      p = m.apply({\n        x: x,\n        y: y\n      });\n      transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n    }\n  }\n\n  if (matrix) {\n    transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n  } else if (offsetX || offsetY) {\n    transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n  }\n\n  return rawPath;\n},\n    _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {\n  var cache = target._gsap,\n      harness = cache.harness,\n      alias = harness && harness.aliases && harness.aliases[property],\n      prop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n  pt.path = rawPath;\n  pt.pp = pathProperty;\n\n  plugin._props.push(prop);\n},\n    _sliceModifier = function _sliceModifier(start, end) {\n  return function (rawPath) {\n    return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;\n  };\n};\n\nexport var MotionPathPlugin = {\n  version: \"3.10.3\",\n  name: \"motionPath\",\n  register: function register(core, Plugin, propTween) {\n    gsap = core;\n    _getUnit = gsap.utils.getUnit;\n    _toArray = gsap.utils.toArray;\n    PropTween = propTween;\n  },\n  init: function init(target, vars) {\n    if (!gsap) {\n      console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n      return false;\n    }\n\n    if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\n      vars = {\n        path: vars\n      };\n    }\n\n    var rawPaths = [],\n        _vars = vars,\n        path = _vars.path,\n        autoRotate = _vars.autoRotate,\n        unitX = _vars.unitX,\n        unitY = _vars.unitY,\n        x = _vars.x,\n        y = _vars.y,\n        firstObj = path[0],\n        slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1),\n        rawPath,\n        p;\n\n    this.rawPaths = rawPaths;\n    this.target = target;\n\n    if (this.rotate = autoRotate || autoRotate === 0) {\n      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n      this.rOffset = parseFloat(autoRotate) || 0;\n      this.radians = !!vars.useRadians;\n      this.rProp = vars.rotation || \"rotation\"; // rotation property\n\n      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n\n      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n    }\n\n    if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n      for (p in firstObj) {\n        if (!x && ~_xProps.indexOf(p)) {\n          x = p;\n        } else if (!y && ~_yProps.indexOf(p)) {\n          y = p;\n        }\n      }\n\n      if (x && y) {\n        //correlated values\n        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n      } else {\n        x = y = 0;\n      }\n\n      for (p in firstObj) {\n        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n      }\n    } else {\n      rawPath = slicer(_align(getRawPath(vars.path), target, vars));\n      cacheRawPathMeasurements(rawPath, vars.resolution);\n      rawPaths.push(rawPath);\n\n      _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n\n      _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n    }\n  },\n  render: function render(ratio, data) {\n    var rawPaths = data.rawPaths,\n        i = rawPaths.length,\n        pt = data._pt;\n\n    if (ratio > 1) {\n      ratio = 1;\n    } else if (ratio < 0) {\n      ratio = 0;\n    }\n\n    while (i--) {\n      getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n    }\n\n    while (pt) {\n      pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n      pt = pt._next;\n    }\n\n    data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n  },\n  getLength: function getLength(path) {\n    return cacheRawPathMeasurements(getRawPath(path)).totalLength;\n  },\n  sliceRawPath: sliceRawPath,\n  getRawPath: getRawPath,\n  pointsToSegment: pointsToSegment,\n  stringToRawPath: stringToRawPath,\n  rawPathToString: rawPathToString,\n  transformRawPath: transformRawPath,\n  getGlobalMatrix: getGlobalMatrix,\n  getPositionOnPath: getPositionOnPath,\n  cacheRawPathMeasurements: cacheRawPathMeasurements,\n  convertToPath: function convertToPath(targets, swap) {\n    return _toArray(targets).map(function (target) {\n      return _convertToPath(target, swap !== false);\n    });\n  },\n  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {\n    var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n    return point ? m.apply(point) : m;\n  },\n  getAlignMatrix: _getAlignMatrix,\n  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n\n    return {\n      x: m.e,\n      y: m.f\n    };\n  },\n  arrayToRawPath: function arrayToRawPath(value, vars) {\n    vars = vars || {};\n\n    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n\n    vars.relative && _relativize(segment);\n    return [vars.type === \"cubic\" ? segment : pointsToSegment(segment, vars.curviness)];\n  }\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\nexport { MotionPathPlugin as default };"]},"metadata":{},"sourceType":"module"}